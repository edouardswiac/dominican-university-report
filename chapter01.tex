\chapter{Erlang/OTP in telephony systems}
\label{ch:erlang}

\section{Overview of Erlang}
Erlang is a general-purpose concurrent, garbage-collected programming language and runtime system. The sequential subset of Erlang is a functional language, with strict evaluation, single assignment, and dynamic typing.

It was designed by Ericsson to support distributed, fault-tolerant, soft-real-time, non-stop applications. It supports hot swapping, so that code can be changed without stopping a system. Hot swapping is particularly suitable for high availability systems like telephony systems.

Erlang was developed to solve the “time-to-market” requirements of distributed, fault-tolerant, massively concurrent, soft real-time systems, and was designed with the aim of improving the development of telephony applications.

The language has been battle tested in real large scale industrial products, like the AXD301 switch in 1998, containing over a million lines of Erlang, and reported to achieve a reliability of 99.999\% (5.26 minutes downtime / year).

Erlang was influenced by functional languages such as ML and Miranda, concurrent languages such as ADA, Modula, and Chill, as well as the Prolog logic programming language.

\section{Strengh of Erlang for telephony system}
One of the greatest strength of Erlang for scalable soft real-time communication systems is its concurrency model. Erlang concurrency is fast and scalable, and can handle high loads with no degradation in throughput, even during sustained peaks. Telephony systems must not suffer from call peaks to be reliable.

Erlang makes parallel programming easy by modeling the world as sets of parallel processes that can interact only by exchanging asymchronous messages. Rather than providing threads that share memory, each Erlang process executes in its own memory space and owns its own heap and stack. Processes can’t interfere with each other inadvertently. There are no locks, no synchronized methods, and no possibility of shared memory corruption, since there is no shared memory, which ensure a high stability of the platform, hence lowered downtimes.

Erlang programs can be made from thousands to millions of extremely lightweight processes that can run on a single processor, can run on a multicore processor, or can run on a network of processors. Concurrency in Erlang belongs to the programming language and not the operating system, which makes Erlang portable over different platforms  (UNIX/Linux, Windows, Mac OS) and architures (x64, x86). 

Functional programming forbids code with side effects, which Erlang implements as referential transparency. Referential transparency requires the same results for a given set of inputs at any point in time thus a referentially transparent expression is therefore deterministic by definition. Bugs and errors in a deterministic system are easier to reproduce than in a non-determistic one.

%It’s about concurrency. It’s about distribution. It’s about fault tolerance. It’s about functional programming. It’s about programming a distributed concurrent system without locks and mutexes but using only pure message passing. It’s about speeding up your programs on multicore CPUs. It’s about writing distributed applications that allow people to interact with each other. It’s about design methods and behaviors for writing fault-tolerant and distributed systems. It’s about modeling concurrency and mapping those models onto computer programs, a process I call concurrency-oriented programming.For concurrency it follows the Actor model. 

\section{Open Telephony Platform}
OTP is simultaneously a framework, a set of libraries, and a methodology for structuring applications; it’s an extension of Erlang.
These are some of the main advantages of OTP:
\begin{description}
\item[Productivity] Using OTP makes it possible to produce production-quality systems in a very short time.
\item[Stability] Code written on top of OTP can focus on the logic and avoid error-prone reimplementations of the typical things that every real-world system needs: process management, servers, state machines, and so on.
\item[Supervision] The application structure provided by the framework makes it sim- ple to supervise and control the running systems, both automatically and through graphical user interfaces.
\item[Upgradability] The framework provides patterns for handling code upgrades in a systematic way.
\item[Reliable code base] The code for the OTP framework is rock solid and has been thoroughly battle tested.
\end{description}

\section{Applications of Erlang/OTP in industry-level communication systems}
\begin{description}
\item[T-Mobile] uses Erlang in its SMS and authentication systems.
\item[Motorola] is using Erlang in call processing products in the public-safety industry.
\item[Ericsson] uses Erlang in its support nodes, used in GPRS and 3G mobile networks worldwide.
\item[Facebook] is using Erlang in the back-end of its chat system.
\end{description}

The fact that web services, retail and commercial banking, computer telephony, messaging systems, and enterprise integration, to mention but a few, happen to share the same requirements as telecom systems explains why Erlang is gaining headway in these sectors.